	SUBTTL	DISPLAY DRIVER
	page

;================================================
;= DISPLAY DRIVER                               =
;================================================

GRAPH:	DB	0		; GRAPHICAL MODE FLAG
LINTEM:	DW	0		; SAVE AREA FOR ESCDL

CPLHL:	LD	A,H		; PROCEDURE COMPLEMENT_HL;
	CPL			; BEGIN
	LD	H,A		;   H:=CPL(H);
	LD	A,L		;   L:=CPL(L);
	CPL			; END;
	LD	L,A		;
	RET			;

NEGHL:	CALL	CPLHL		; PROCEDURE NEGATE_HL;
	INC	HL		; COMPLEMENT_HL;
	RET			; HL:=HL+1;

TSTLROW:LD	HL,(RCTAD)	; PROCEDURE TEST_LAST_ROW;
	LD	A,L		; BEGIN
	CP	128		;   IF ROW=1920 THEN Z_FLG := SET
	RET	NZ		;               ELSE Z_FLG := RESET;
	LD	A,H		; END;
	CP	7		;
	RET			;

CONV:	LD	A,(GRAPH)	; PROCEDURE CONVERT_CHAR;
	OR	A		; IF GRAPH THEN
	LD	A,C		;   A:=CHAR
	RET	NZ		; ELSE
CON1:	LD	B,0		;   A:=CONVERT(CHAR);
	ADD	HL,BC		;
	LD	A,(HL)		;
	RET			;

WP75:	PUSH	AF		; PROCEDURE CURSOR_POSITION;
	LD	A,80H		; (* LOAD CURSOR COMMAND *)
	OUT	(DSPLC),A	;
	LD	A,(CCTAD)	;
	OUT	(DSPLD),A	; (* X POSITION *)
	LD	A,(CURSY)	;
	OUT	(DSPLD),A	; (* Y POSITION *)
	POP	AF		;
	RET			;
	PAGE


ROWDN:	LD	HL,(RCTAD)	; PROCEDURE ROW_DOWN;
	LD	DE,80		; BEGIN
	ADD	HL,DE		;   ROW:=ROW+80;
	LD	(RCTAD),HL	;   CURSY:=CURSY+1;
	LD	HL,CURSY	;   CURSOR_POSITION(COLUMN,CURSY);
	INC	(HL)		; END;
	JP	WP75		;

ROWUP:	LD	HL,(RCTAD)	; PROCEDURE ROW_UP;
	LD	DE,-80		; BEGIN
	ADD	HL,DE		;   ROW:=ROW-80;
	LD	(RCTAD),HL	;   CURSY:=CURSY-1;
	LD	HL,CURSY	;   CURSOR_POSITION(COLUMN,CURSY);
	DEC	(HL)		; END;
	JP	WP75		;

ES0H:	LD	HL,0		; PROCEDURE HOME;
	LD	(RCTAD),HL	; BEGIN
	XOR	A		;   ROW:=0;
	LD	(CCTAD),A	;   COLUMN:=0;
	LD	(CURSY),A	;   CURSY:=0;
	RET			; END;

CHKDC:	CP	B		; PROCEDURE A_MOD_B;
	RET	C		; BEGIN
	SUB	B		;   A:=A MOD B;
	JP	CHKDC		; END;

	PAGE

FILL:	LD	HL,(LOCBUF)	; PROCEDURE FILL_LINE_WITH_SPACES;
	LD	D,H		; BEGIN
	LD	E,L		;   SOURCE:=LOCBUF;
	INC	DE		;   DESTINATION:=LOCBUF+1;
	LD	BC,79		;   COUNT:=79; (SOURCE):='SP';
	LD	(HL),32		;   MOVEBYTES(SOURCE,DESTINATION,COUNT);
	LDIR			;   IF BACKGROUND THEN
	LD	A,(BGFLG)	;   BEGIN
	CP	0		;     SOURCE:=LOCBBU;
	RET	Z		;     DESTINATION:=LOCBBU+1;
	LD	HL,(LOCBBU)	;     COUNT:=9; (* 10 BYTES = 80 BITS *)
	LD	D,H		;     (SOURCE):='NUL';
	LD	E,L		;     MOVEBYTES(SOURCE,DESTINATION,COUNT);
	INC	DE		;   END;
	LD	BC,9		; END;
	LD	(HL),0		;
	LDIR			;
	RET			;

SCROLL:	LD	HL,DSPSTR+80	; PROCEDURE SCROLL;
	LD	DE,DSPSTR	; BEGIN
	LD	BC,1920 	;   SOURCE:=DISPLAY_START+80;
	LDIR			;   DESTINATION:=DISPLAY_START;
	LD	HL,DSPSTR+1920  ;   COUNT:=1920;
	LD	(LOCBUF),HL	;   MOVEBYTES(SOURCE,DESTINATION,COUNT);
	LD	A,(BGFLG)	;   LOCBUF:=DISRLAY_START+1920;
	CP	0		;   IF BACKGROUND THEN
	JP 	Z,FILL		;   BEGIN
	LD	HL,BGSTAR+10	;     SOURCE:=BGSTAR+10;
	LD	DE,BGSTAR	;     DESTINATION:=BGSTAR;
	LD	BC,240		;     COUNT:=240;
	LDIR			;     MOVEBYTES(SOURCE,DESTINATION,COUNT);
	LD	HL,BGSTAR+240	;     LOCBBU:=BGSTAR+240; (*LAST LINE*)
	LD	(LOCBBU),HL	;   END;
	JP	FILL		;   FILL_LINE_WITH_SPACES;
				; END;

	PAGE

ADDOFF:	LD	A,0		; PROCEDURE BACKGROUND_ADDRESS_CALCULATION;
	LD	B,3		; BEGIN
ADDOF1:	SRL	H		;   A:=HL MOD 8; (* BIT NUMBER *)
	RR	L		;   HL:=HL DIV 8; (* BYTE OFFSET IN BG *)
	RRA			; END;
	DEC	B		;
	JP	NZ,ADDOF1	;
	CP	0		;
	RET	Z		;
	LD	B,5		;
ADDOF2:	RRA			;
	DEC	B		;
	JP	NZ,ADDOF2	;
	RET			;

CLRBIT:	LD	DE,BGSTAR	; PROCEDURE CLEAR_REST_OF_BITS;
	ADD	HL,DE		; BEGIN
	CP	0		;   (* ENTRY:A=BIT NO, HL=BG OFFSET *)
	LD	B,A		;
	LD	A,0		;   HL:=BGSTAR+BGOFFSET;
	JP	NZ,CLRBI1	;   IF BITNO=0 THEN
	AND	(HL)		;     (HL):='NUL'
	LD	(HL),A		;   
	RET			;   ELSE
CLRBI1:	SCF			;     FOR I:=0 TO BITNO DO
	RLA			;       (HL).I:=0; (* CLEAR BIT #I *)
	DEC	B		;   
	JP	NZ,CLRBI1	;     
	AND	(HL)		;   
	LD	(HL),A		;
	RET			; END;

	PAGE

MOVUP:	LD	A,0		;
	CP	C		;
	JP	Z,MOVUP2	;
MOVUP1:	LDIR			;
	RET			;
MOVUP2:	CP	B		;
	JP	NZ,MOVUP1	;
	RET			;

MOVDWN:	LD	A,0		;
	CP	C		;
	JP	Z,MOVDWN2	;
MOVDWN1:LDDR			;
	RET			;
MOVDWN2:CP	B		;
	JP	NZ,MOVDWN1	;
	RET			;

	PAGE

;========================================================
;= CONTROL CHARACTER TREATMENT                          =
;========================================================

CTLG:	OUT	(BELL),A	; PROCEDURE BELL;
	RET			;

CTLF:	CALL	ES0H		; PROCEDURE START_XY_ADDRESSING;
	LD	A,2		; HOME;
	LD	(XFLG),A	; XFLG:=2;
	RET			;

DUMMY:	RET			; PROCEDURE DUMMY;
				; BEGIN END;

CTLM:	LD	A,0		; PROCEDURE CARRIAGE_RETURN;
	LD	(CCTAD),A	; COLUMN:=0;
	JP	WP75		; CURSOR_POSITION(COLUMN,CURSY);

ESCE:	LD	HL,DSPSTR+1999	; PROCEDURE CLEAR_SCREEN;
	LD	DE,DSPSTR+1998	; BEGIN
	LD	BC,1999		;   SOURCE:=DISPLAY_START+1999;
	LD	(HL),32		;   DESTINATION:=DISPLAY_START+1999-1;
	LDDR			;   COUNT:=1999;
	CALL	ES0H		;   (SOURCE):='SP';
	CALL	WP75		;   MOVEBYTES(SOURCE,DESTINATION,COUNT);
	LD	A,(BGFLG)	;   HOME;
	CP	0		;   CURSOR_POSITION(COLUMN,CURSY);
	RET	Z		;   IF BACKGROUND THEN (* CLEAR FLAGS *)
	XOR	A		;   BEGIN
	LD	(BGFLG),A	;     BACKGROUND:=FALSE;
	LD	HL,BGSTAR+249	;     SOURCE:=BGSTAR+240;
	LD	DE,BGSTAR+248	;     DESTINATION:=BGSTAR+240-1;
	LD	BC,249		;     COUNT:=249;
	LD	(HL),0		;     (SOURCE):='NUL';
	LDDR			;     MOVEBYTES(SOURCE,DESTINATION,COUNT);
	RET			;   END;
				; END;
	PAGE

ESCK:	LD	DE,DSPSTR	; PROCEDURE ERASE_TO_END_OF_LINE;
	LD	HL,(RCTAD)	; BEGIN
	ADD	HL,DE		;   SOURCE:=DISPLAY_START_ROW+79;
	LD	DE,79		;   DESTINATION:=DISPLAY_START+ROW+79-1;
	ADD	HL,DE		;   COUNT:=79-COLUMN;
	LD	D,H		;   (SOURCE):='SP';
	LD	E,L		;   IF COUNT<>0 THEN
	DEC	DE		;     MOVEBYTES(SOURCE,DESTINATION,COUNT);
	LD	BC,0		;
	LD	A,(CCTAD)	;
	CPL			;
	INC	A		;
	ADD	A,79		;
	LD	C,A		;
	LD	(HL),32		;
	CALL	MOVDWN		;
	LD	A,(BGFLG)	;
	CP	0		;
	RET	Z		;   IF BACKGROUND THEN
	LD	HL,(RCTAD)	;   BEGIN
	LD	D,0		;
	LD	A,(CCTAD)	;
	LD	E,A		;
	ADD	HL,DE		;     BGOFFSET:=(ROW+CDLUMN) DIV 8;
	CALL	ADDOFF		;     BITNO:=(ROW+COLUMN) MOD 8;
	CALL	CLRBIT		;     CLRBIT;
	LD	A,(CCTAD)	;
	SRL	A		;     IF COLUMN<79 THEN
	SRL	A		;     BEGIN (* MORE BG BYTES TO CLEAR *)
	SRL	A		;
	CPL			;
	ADD	A,9		;       COUNT:=9-(COLUMN DIV 8);
	RET	M		;
	LD	C,A		;
	LD	B,0		;       DESTINATION:=BGOFFSET+1+1;
	INC	HL		;       SOURCE:=BGOFFSET+1;
	LD	D,H		;       IF COUNT<>0 THEN
	LD	E,L		; 	  MOVEBYTES(SOURCE,DESTINATION,COUNT);
	INC	DE		;       END;
	LD	A,0		;   END;
	JP	MOVUP		; END;

	PAGE

ESCY:	LD	HL,(RCTAD)	; PROCEDURE ERASE_TO_END_OF_SCREEN;
	LD	A,(CCTAD)	; BEGIN
	LD	C,A		;   SOURCE:=DISPLAY_START+1999;
	LD	B,0		;   DESTINATION:=DISPLAY_START+1999-1;
	ADD	HL,BC		;   COUNT:=1999-(ROW+COLUMN);
	CALL	NEGHL		;   (SOURCE):='SP';
	LD	DE,1999		;   IF COUNT>O THEN
	ADD	HL,DE		;     MOVEBYTES(SOURCE,DESTINATION,COUNT);
	LD	B,H		;   IF BACKGROUND THEN
	LD	C,L		;   BEGIN
	LD	HL,DSPSTR+1999	;     BGOFFSET:=(COLUMN+ROW) DIV 8;
	LD	DE,DSPSTR+1998	;     BITNO:=(ROW+COLUMN) MOD 8; CLRBIT;
	LD	(HL),32		;     COUNT:=248-BGOFFSET;
	CALL	MOVDWN		;     SOURCE:=BGSTAR+249;
	LD	A,(BGFLG)	;     DESTINATION:=BGSTAR+249-1;
	CP	0		;     (SOURCE):='NUL';
	RET	Z		;     IF COUNT<>0 THEN
	LD	HL,(RCTAD)	;       MOVEBYTES(SOURCE,DESTINATIDN,COUNT);
	LD	D,0		;     END;
	LD	A,(CCTAD)	; END;
	LD	E,A		;
	ADD	HL,DE		;
	CALL	ADDOFF		;
	CALL	CLRBIT		;
	CALL	CPLHL		;
	LD	DE,BGSTAR+249	;
	ADD	HL,DE		;
	LD	A,80H		;
	AND	H		;
	RET	NZ		;
	LD	B,H		;
	LD	C,L		;
	LD	H,D		;
	LD	L,E		;
	DEC	DE		;
	LD	(HL),0		;
	JP	MOVDWN		;

	PAGE

ESCD:	LD	A,(CCTAD)	; PROCEDURE CURSOR_LEFT;
	CP	0		; BEGIN
	JP	Z,ESCD1		;   IF COLUNN<>0 THEN
	DEC	A		;   BEGIN
	LD	(CCTAD),A	;     COLUMN:=COLUMN-1;
	JP	WP75		;     CURSOR_POSITION(COLUMN,CURSY);
ESCD1:	LD	A,79		;   END ELSE
	LD	(CCTAD),A	;   BEGIN
	LD	HL,(RCTAD)	;     COLUMN:=79;
	LD	A,L		;     IF ROW<>0 THEN
	OR	H		;       ROW_UP
	JP	NZ,ROWUP	;     ELSE
	LD	HL,1920		;     BEGIN
	LD	(RCTAD),HL	;       ROW:=1920;
	LD	A,24		;       CURSY:=24;
	LD	(CURSY),A	;       CURSOR_POSITION(COLUMN,CURSY);
	JP	WP75		;     END;
				;   END ;
				; END;

ESCC:	LD	A,(CCTAD)	; PROCEDURE CURSOR_RIGTH;
	CP	79		; BEGIN
	JP 	Z,ESCC1		;   IF COLUMN<>79 THEN
	INC	A		;   BEGIN
	LD	(CCTAD),A	;     COLUMN:=COLUMN+1;
	JP	WP75		;     CURSOR_POSITION(COLUMN,CURSY);
ESCC1:	LD	A,0		;   END ELSE
	LD	(CCTAD),A	;   BEGIN
	CALL	TSTLROW		;     COLUMN:=0;
	JP	NZ,ROWDN	;     IF ROW<>1920 THEN ROW_DOWN
	CALL	WP75		;     ELSE
	JP	SCROLL		;     BEGIN
				;       CURSOR_POSITION(COLUMN,CURSY);
				;       SCROLL;
				;     END;
				;   END;
				; END;

	PAGE

CTAB:	CALL	ESCC		; PROCEDURE TABULATE;
	CALL	ESCC		;
	CALL	ESCC		;   FOR I:=1 TO 4 DO CURSOR_RIGHT;
	JP	ESCC		; END;

ESCB:	CALL	TSTLROW		; PROCEDURE CURSOR_DOWN;
	JP	NZ,ROWDN	;   IF ROW<>1920 THEN ROW_DOWN
	JP	SCROLL		;                ELSE SCROLL;

ESCA:	LD	HL,(RCTAD)	; PROCEDURE CURSOR_UP;
	LD	A,L		;   IF ROW<>0 THEN ROW_UP
	OR	H		;   ELSE
	JP	NZ,ROWUP	;   BEGIN
	LD	HL,1920		;     ROW:=1920;
	LD	(RCTAD),HL	;     CURSY:=24;
	LD	A,24		;     CURSOR_POSITION(COLUMN,CURSY);
	LD	(CURSY),A	;   END;
	JP	WP75		;

ESCH:	CALL	ES0H		; PROCEDURE HOME;
	JP	WP75		; ES0H;
				; CURSOR_POSITION(COLUMN,CURSY);

	PAGE

ESCDL:	LD	HL,(RCTAD)	; PROCEDURE DELETE_LINE;
	LD	B,H		; BEGIN
	LD	C,L		;   SOURCE:=DISPLAY_START+ROW+80;
	LD	DE,DSPSTR+80	;   DESTINATION:=DISPLAY_START+ROW;
	ADD	HL,DE		;   COUNT:=1920-ROW;
	LD	(LINTEM),HL	;   IF COUNT<>0 THEN  
	LD	DE,-80		;     MOVEBYTES(SOURCE,DESTINATION,COUNT);
	ADD	HL,DE		;   LOCBUF:=DISPLAY_START+1920;
	EX	DE,HL		;   IF BACKGROUND THEN
	LD	H,B		;   BEGIN
	LD	L,C		;     BGOFFSET:=ROW DIV 8;
	CALL	NEGHL		;     BITNO:=ROW MOD 8;
	LD	BC,1920		;     SOURCE:=BGSTAR+BGOFFSET+10;
	ADD	HL,BC		;     DESTINATION:=BGSTAR+BGOFFSET;
	LD	B,H		;     COUNT:=240-BGOFFSET;
	LD	C,L		;     IF COUNT<>0 THEN
	LD	HL,(LINTEM)	;       MOVEBYTES(SOURCE,DESTINATION,COUNT);
	CALL	MOVUP		;     LOCBBU:=BGSTAR+240;
	LD	HL,DSPSTR+1920	;   END;
	LD	(LOCBUF),HL	;   FILL_LINE_WITH_SPACES;
				; END ;
	PAGE

	LD	A,(BGFLG)	; BACKGROUND HANDLING;
	CP	0		;
	JP	Z,FILL		;
	LD	HL,(RCTAD)	;
	CALL	ADDOFF		;
	LD	B,H		;
	LD	C,L		;
	LD	DE,BGSTAR+10	;
	ADD	HL,DE		;
	LD	(LINTEM),HL	;
	LD	DE,-10		;
	ADD	HL,DE		;
	EX	DE,HL		;
	LD	H,B		;
	LD	L,C		;
	CALL	NEGHL		;
	LD	BC,240		;
	ADD	HL,BC		;
	LD	B,H		;
	LD	C,L		;
	LD	HL,(LINTEM)	;
	CALL	MOVUP		;
	LD	HL,BGSTAR+240	;
	LD	(LOCBBU),HL	;
	JP	FILL		;

	PAGE

ESCIL:	LD	HL,(RCTAD)	; PROCEDURE INSERT_LINE
	LD	DE,DSPSTR	; BEGIN
	ADD	HL,DE		;   SOURCE:=1919;
	LD	(LOCBUF),HL	;   DESTINATION:=1999;
	CALL	NEGHL		;   COUNT:=1920-ROW;
	LD	DE,DSPSTR+1920	;   IF COUNT<>0 THEN
	ADD	HL,DE		;     MOVEBYTES(SOURCE,DESTINATION,COUNT);
	LD	B,H		;   IF BACKGROUND THEN
	LD	C,L		;   BEGIN
	LD	HL,DSPSTR+1919	;     BGOFFSET:=ROW DIV 8;
	LD	DE,DSPSTR+1999	;     BITNO:=ROW MOD 8;
	CALL	MOVDWN		;     LOCBBU:=BGSTAR+BGOFFSET;
	LD	A,(BGFLG)	;     SOURCE:=BGSTAR+239;
	CP	0		;     DESTINATION:=BGSTAR+249;
	JP	Z,FILL		;     COUNT:=240-BGOFFSET;
	LD	HL,(RCTAD)	;     IF COUNT<>O THEN
	CALL	ADDOFF		;       MOVEBYTES(SOURCE,DESTINATION,COUNT);
	LD	DE,BGSTAR	;     END;
	ADD	HL,DE		;
	LD	(LOCBBU),HL	;
	CALL	NEGHL		;
	LD	DE,BGSTAR+240	;
	ADD	HL,DE		;
	LD	B,H		;
	LD	C,L		;
	LD	HL,BGSTAR+239	;
	LD	DE,BGSTAR+249	;
	CALL	MOVDWN		;
	JP	FILL		;

	PAGE

ESCSB:	LD	A,2		; PROCEDURE SET_BACKGROUND;
	LD	(BGFLG),A	;
	RET			;

ESCSF:	LD	A,1		; PROCEDURE SET_FOREGROUND;
	LD	(BGFLG),A	;
	RET			;

ESCCF:	LD	HL,DSPSTR	; PROCEDURE CLEAR_FOREGROUND;
	LD	DE,BGSTAR	; BEGIN
	LD	B,250		;   HL:=DISPLAY_START;
ESCCF1: LD	A,(DE)		;   DE:=BGSTAR;
	LD	C,8		;   FOR B:=250 DOWNTO 1 DO
	CP	0		;   BEGIN
	JP	NZ,ESCCF3	;     IF (DE)=0 THEN
ESCCF2:	LD	(HL),32		;     FOR C:=8 DOWNTO 1 DO
	INC	HL		;     BEGIN
	DEC	C		;       (HL):='SP';
	JP	NZ,ESCCF2	;       HL:=HL+1;
	JP	ESCCF5		;     END
ESCCF3:	RRA			;     ELSE
	JP	C,ESCCF4	;       FOR C:=8 DOWN TO 1 DO
	LD	(HL),32		;       BEGIN
ESCCF4:	INC	HL		;         IF (DE) AND (1 SHIFT (8-C))=1 THEN
	DEC	C		;           (HL):='SP';
	JP	NZ,ESCCF3	;         HL:=HL+1;
ESCCF5:	INC	DE		;       END;  
	DEC	B		;   END;
	JP	NZ,ESCCF1	; END;
	RET			;

	PAGE

;=======================================================
;= CONTROL CHARACTER JUMP TABLE                        =
;=======================================================

TAB1:	DW	DUMMY 		; DUMMY;
	DW	ESCIL		; INSERT_LINE;
	DW	ESCDL		; DELETE_LINE;
	DW	DUMMY		; DUMMY;
	DW	DUMMY		; DUMMY;
	DW	ESCD		; CURSOR_LEFT;
	DW	CTLF		; START_XY_ADDRESSING;
	DW	CTLG		; BELL;
	DW	ESCD		; CURSOR_LEFT;
	DW	CTAB		; TABULATION;
	DW	ESCB		; CURSOR_DOWN;
	DW	DUMMY		; DUMMY;
	DW	ESCE		; CLEAR_SCREEN;
	DW	CTLM		; CARRIAGE_RETURN;
	DW	DUMMY		; DUMMY;
	DW	DUMMY		; DUMMY;
	DW	DUMMY		; DUMMY;
	DW	DUMMY		; DUMMY;
	DW	DUMMY		; DUMMY;
	DW	DUMMY		; DUMMY;
	DW	ESCSB		; SET_BACKGROUND;
	DW	ESCSF		; SET_FOREGROUND;
	DW	ESCCF		; CLEAR_FOREGROUND;
	DW	DUMMY		; DUMMY;
	DW	ESCC		; CURSOR_RIGHT;
	DW	DUMMY		; DUMMY;
	DW	ESCA		; CURSOR_UP;
	DW	DUMMY		; DUMMY;
	DW	DUMMY		; DUMMY;
	DW	ESCH		; CURSOR_HOME;
	DW	ESCK		; ERASE_TO_END_OF_LINE;
	DW	ESCY		; ERASE_TO_END_OF_SCREEN;

	PAGE

SPECC:	LD	A,0		;PROCEDURE CONTROL_CHAR;
	LD	(XFLG),A	;BEGIN
	LD	A,(USHER)	;  CANSEL POSSIBLE X-Y ADDRESSING
	RLCA			;
	AND	3EH		;  OFFSET := CHAR * 2;
	LD	C,A		;
	LD	B,0		;
	LD	HL,TAB1		;
	ADD	HL,BC		;
	LD	E,(HL)		;
	INC	HL		;
	LD	D,(HL)		; JR (TABLE + OFFSET)
	EX	DE,HL		;
	JP	(HL)		;END;

;=======================================================
;= END OF CONTROL CHARACTER TREATMENT                  =
;=======================================================

	PAGE

;================================================
;= X-Y ADDRESSING                               =
;================================================

XYADD:	LD	A,(USHER)	; PROCEDURE XYADDRESS;
	AND	127		; BEGIN
	SUB	32		;   CHAR:=(CHAR AND 127)-32; XFLG:=XFLG-1;
	LD	HL,XFLG		;   IF XFLG>O THEN ADR0:=CHAR
	DEC	(HL)		;   ELSE (* LAST BYTE OF ADDRESS *)
	JP	Z,XYADD1	;   BEGIN
	LD	(ADR0),A	;     IF ADRMDDE=0 THEN
	RET			;     BEGIN (* XY MODE *)
XYADD1:	LD	D,A		;       CURSY:=CHAR MOD 25;
	LD	A,(ADR0)	;       ROW:=ROW+CHAR*80;
	LD	H,A		;       COLUMN:=ADR0 MOD 80;
	LD	A,(ADRMOD)	;     END
	OR	A		;     ELSE (* YX MODE *)
	JP 	Z,XYADD2	;     BEGIN
	EX	DE,HL		;       CURSY:=ADR0 MOD 25;
XYADD2:	LD	A,H		;       ROW:=ROW+ADR0*80;
	LD	B,80		;       COLUMN:=CHAR MOD 80;
	CALL	CHKDC		;     END;
	LD	(CCTAD),A	;   END;
	LD	A,D		; END;
	LD	B,25		;
	CALL	CHKDC		;
	LD	(CURSY),A	;
	OR	A		;
	JP	Z,WP75		;
	LD	HL,(RCTAD)	;
	LD	DE,80		;
XYADD3:	ADD	HL,DE		;
	DEC	A		;
	JP	NZ,XYADD3	;
	LD	(RCTAD),HL	;
	JP	WP75		;

	PAGE

;================================================
;= NORMAL CHARACTER TREATMENT                   =
;================================================

DISPL:	LD	HL,(RCTAD)	; PROCEDURE DISPLAY_CHARACTER;
	LD	D,0		; BEGIN
	LD	A,(CCTAD)	;   LOCAD:=ROW+COLUMN;
	LD	E,A		;
	ADD	HL,DE		;
	LD	(LOCAD),HL	;
	LD	A,(USHER)	;
	CP	192		;
	JP	C,DISPL1	;   IF CHAR > 192 THEN
	SUB	192		;     CHAR := CHAR -192;
DISPL1:	LD	C,A		;
	CP	128		;
	JP	C,DISPL2	;   IF CHAR > 128 THEN
	AND	4		;
	LD	(GRAPH),A	;     GRAPH := TRUE
	LD	A,C		;
	JP	DISPL3		;
DISPL2:	LD	HL,OUTCON	;   ELSE
	CALL	CONV		;     CONVERT(CHAR);
DISPL3:	LD	HL,(LOCAD)	; (DISPLAY_START+LOCAD):=CHAR;
	LD	DE,DSPSTR	;
	ADD	HL,DE		;
	LD	(HL),A		;
	CALL	ESCC		; CURSOR_RIGTH;

	PAGE

	LD	A,(BGFLG)	;   IF BACKGROUND THEN
	CP	2		;   BEGIN
	RET	NZ		;     BGOFFSET:=LOCAD DIV 8;
	LD	HL,(LOCAD)	;     BITNO:=LOCAD MOD 8;
	CALL	ADDOFF		;     BGADDR:=BGSTAR+BGOFFSET;
	LD	DE,BGSTAR	;     (BBADDR):=(BGADDR) OR (1 SHIFT BITNO);
	ADD	HL,DE		;
	CP	0		;
	LD	B,A		;
	LD	A,1		;
	JP	NZ,DISPL4	;
	OR	(HL)		;
	LD	(HL),A		;
	RET			;
DISPL4:	RLCA			;
	DEC	B		;
	JP	NZ,DISPL4	;
	OR	(HL)		;
	LD	(HL),A		;   END;
	RET			; END;

	PAGE

CONOUT:	DI			; PROCEDURE CONSOLE_OUTPUT;
	PUSH	HL		; BEGIN
	LD	HL,0		;   IF XFLG<>0 THEN
	ADD	HL,SP		;     XYADD
	LD	SP,STACK	;   ELSE
	EI			;     IF CHAR<32 THEN
	PUSH	HL		; 	SPECC
	PUSH	AF		;     ELSE
	PUSH	BC		;       DISPLAY_CHARACTER;
	PUSH	DE		;     END;
	LD	A,C		;
	LD	(USHER),A	;
	LD	A,(XFLG)	;
	OR	A		;
	JP	Z,CONOU1	;
	CALL	XYADD		;
	JP	CONOU3		;
CONOU1:	LD	A,(USHER)	;
	CP	32		;
	JP	NC,CONOU2	;
	CALL	SPECC		;
	JP	CONOU3		;
CONOU2:	CALL	DISPL		;
CONOU3:	POP	DE		;
	POP	BC		;
	POP	AF		;
	POP	HL		;
	DI			;
	LD	SP,HL		;
	POP	HL		;
	EI			;
	RET			;

	PAGE

;===============================================================
;= INTEL 8275 DISPLAY CONTROLLER INTERRUPT ROUTINE             =
;===============================================================

DSPITR:	LD	(SP_SAV),SP	; SAVE ACCUMULATOR AND FLAGS
	LD	SP,ISTACK	; SAVE REGISTERS
	PUSH	AF		;
	PUSH	BC		;
	PUSH	DE		; ESTABLISH LOCAL STACK
	PUSH	HL		; SAVE GLOBAL STACK POINTER
	IN	A,(DSPLC)	;
	LD	A,6		;
	OUT	(DMAMAS),A	; SET DMA CH2 MASK;
	LD	A,7		;
	OUT	(DMAMAS),A	; SET DMA CH3 MASK;
	OUT	(DMACBC),A	; CLEAR DMA BYTECOUNTER;
	LD	HL,DSPSTR	;
	LD	A,L		;
	OUT	(DMAAD2),A	; SET DMA CH2 LOW ADDRESS;
	LD	A,H		;
	OUT	(DMAAD2),A	; SET DMA CH2 HIGH ADDRESS;
	LD	HL,1999		;
	LD	A,L		;
	OUT	(DMACN2),A	; SET DMA CH2 LOW BYTECOUNT;
	LD	A,H		;
	OUT	(DMACN2),A	; SET DMA CH2 HIGH BYTECOUNT;
	LD	A,0		;
	OUT	(DMACN3),A	; SET DMA CH3 LOW BYTE COUNT;
	OUT	(DMACN3),A	; SET DMA CH3 HIGH BYTE COUNT;
	LD	A,2		;
	OUT	(DMAMAS),A	; CLEAR CH2 MASK;
	LD	A,3		;
	OUT	(DMAMAS),A	; CLEAR CH3 MASK;
	LD	A,0D7H		;
	OUT	(CTCCH2),A	; SET CTC CH2 MODE;
	LD	A,1		;
	OUT	(CTCCH2),A	; SET CTC CH2 COUNT;

	PAGE

	LD	HL,RTC0		; REAL TIME CLOCK
	INC	(HL)		;
	JP	NZ,AFB11	;
	INC	HL		;
	INC	(HL)		;
	JP	NZ,AFB11	;
	INC	HL		;
	INC	(HL)		;
	JP	NZ,AFB11	;
	INC	HL		;
	INC	(HL)		;
AFB11:	LD	HL,(EXCNT0)	; EXIT ROUTINE 0 COUNTER
	LD	A,L		;
	OR	H		;
	JP	Z,AFB12		;
	DEC	HL		;
	LD	A,L		;
	OR	H		;
	LD	(EXCNT0),HL	;
	CALL	Z,EXROUT	;
AFB12:	LD	HL,(EXCNT1)	; EXIT ROUTINE 1 COUNTER
	LD	A,L		;
	OR	H		;
	JP	Z,AFB13		;
	DEC	HL		;
	LD	A,L		;
	OR	H		;
	LD	(EXCNT1),HL	;
	CALL	Z,FDSTOP	;
AFB13:	LD	HL,(DELCNT)	;
	LD	A,L		;
	OR	H		;
	JP	Z,AFB14		;
	DEC	HL		;
	LD	(DELCNT),HL	;
AFB14:	POP	HL		;
	POP	DE		; RESTORE GLOBAL STACKPOINTER
	POP	BC		; RESTORE REGISTERS
	POP	AF		; RESTORE ACCUMULATOR AND FLAGS
	LD	SP,(SP_SAV)	;
 	EI			;
	RETI			;

