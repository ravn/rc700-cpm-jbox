;************************************************************************
;*									*
;* AUTOLOAD-FILE FOR THE RC700 AND RC703 MICROCOMPUTER			*
;*  									*
;* REGNECENTRALEN OCTOBER 1982 JOS					*
;*									*
;************************************************************************ 
.Z80
; GLOBAL CONSTANT DEFINITIONS 
;

COLOR	EQU	0	;SELECT COLOR CRT AUTOLOAD VERSION
			;COLOR=0 MEANS SELECT NON-COLOR CRT AUTOLOAD VERSION
			;
			;
			;			
FMOVE	EQU	2048	;NUMBER OF BYTES IN PROM
FMOVS	EQU	MOVADR-BEGIN
ROM2	EQU	2000H	;ADDRESS OF TEST PROM 
RAMEN	EQU	019H	;ENABLE RAM PORT
SW1	EQU	014H	;MINI/MAXI SWITCH 
BIB	EQU	01CH	;BIB SOUND SWITCH


;MEMORY LAYOUT
TRK	EQU	0B000H	;ID COMAL READ TRACK COUNT

RSTAB	EQU	0B003H	;FLOPPY SAVE STATUS AREA
ERFLAG	EQU	0B00DH	;HARD DISK ERROR FLAG
SECTOR	EQU	0B00EH	;HARD DISK SECTOR READ COUNT
MEMADR	EQU	0B00FH	;MEMORY ADDRESS POINTER (DMA)
REPTIM	EQU	0B011H	;REPEAT OPERATION INDICATOR
DSPSTR	EQU	0B020H	;DISPLAY MEMORY BUFFER
STACK	EQU    	0FFFFH	;STACK AREA BOTTOM ADDRESS
;

PAGE
;*****************************************************************************
;  START OF PROM CODE. THE FIRST CODE BYTES WILL MOVE THE BOOTSTRAP CODE     *
;  IMAGE TO ADDRESS A000 AND FORWARD.                                        *
;*****************************************************************************

		ORG 0	;START IN ADDRESS 0 ABS.
BEGIN:	DI		;
	LD SP,STACK	;SET STACK AREA
	LD HL,FMOVS	;FIRST BYTE TO BE MOVEN
	LD DE,0A000H	;DESTINATION ADDRESS
	LD BC,FMOVE-FMOVS; NUMBER OF BYTES TO MOVE
	LDIR		;MOVE!
	JP AUTOL	;GO TO AUTOLOAD SECTION 
MOVADR:
PAGE
.PHASE 0A000H
;*****************************************************************************
;*                                                                           *
;*    AUTO LOAD SECTION:					             *    
;*									     *
;*****************************************************************************
PRAM:			;ADRESS OF THE FIRST CODEBYTE AFTER MOVING 
;  INTERRUPT TABLE:
ITRTAB:	DW DUMINT	;     DUMMY
	DW KBINT 	;PIO: KEYBOARD	"NOTE MUST NOT BE CHANGED DUE
			;                TO ID-COMAL" 
	DW DUMINT	;     DUMMY
	DW DUMINT	;     DUMMY
	DW HDINT	;CTC2:WD1000
	DW DUMINT	;     DUMMY
	DW DUMINT	;     DUMMY
	DW DUMINT	;     DUMMY
	DW DUMINT	;CTC: DUMMY
	DW DUMINT	;     DUMMY
	DW DISINT	;     DISPLAY
	DW FLPINT	;     FLOPPY
PAGE      		      
AUTOL:	LD A,HIGH(ITRTAB) 
	LD I,A		;SET INTERRUPT VECTOR REGISTER
	IM 2		;INTERRUPT MODE 2

;INITIALIZATION OF Z80 PIO
;  PORT A: USED FOR KEYBOARD
;  PORT B: NOT USED DURING BOOTSTRAP
;
KEYCON	EQU	12H	;CONTROL PORT A
KEYDAT	EQU	10H	;DATA PORT A
MODIN	EQU	4FH	;PIO MODE =INPUT
KINT	EQU	02H	;PIO INTERRUPT VECTOR
PENINT 	EQU	87H	;PIO ENABLE INTERRUPT 
PDIINT	EQU	07H	;PIO DISABLE INTERRUPT 
;
;
;
	LD A,KINT	;SET KEYBOARD INT VEC.
	OUT (KEYCON),A	; 
	LD A,MODIN	;
	OUT (KEYCON),A	;SET INPUT MODE
	LD A,PENINT	;
	OUT (KEYCON),A  ;ENABLE KEYBOARD INTERRUPTS
	IN A,(KEYDAT)	;READ PIA DATA PORT
PAGE
;INITIALIZATION OF THE AM9517 DMA CONTROLLER
;  CHANNEL0: WD1000 HARD DISK CONTROLLER
;  CHANNEL1: FLOPPY DISK CONTROLLER
;  CHANNEL2: DISPLAY CONTROLLER
;  CHANNEL3: NOT USED DURING BOOTSTRAP
;
CH0ADR	EQU	0F0H	;ADDRESS REGISTER CHANNEL0
WCREG0	EQU	0F1H	;WORD COUNT REGISTER CHANNEL0
CH1ADR	EQU	0F2H	;ADDR REG CH1 
WCREG1	EQU	0F3H	;WORD COUNT REG CH1
CH2ADR	EQU	0F4H	;ADDR REG CH2
WCREG2	EQU	0F5H	;WORD COUNT REG CH2
DMACOM	EQU	0F8H	;DMA CONTROLLER COMMAND REGISTER 
DMAMOD	EQU	0FBH	;DMA CONTROLLER MODE REGISTER 
COMV	EQU	020H	;COMMAND VALUE 
MODE0	EQU	044H	;TRANSFER DISK TO MEMORY CH0
MODE1	EQU	045H	;TRANSFER DISK TO MEMORY CH1
MODE2	EQU	05AH	;TRANSFER MEMORY TO DISPLAY CH2(AUTOINITIALIZE)
CLBP	EQU	0FCH	;CLEAR BYTE COUNTER REGISTER
DMAMSK	EQU	00FH	;SET ALL DMA CHANNELS MASKBITS
CLR0	EQU	000H	;CLEAR CH0 MASK BIT 
CLR1	EQU	001H	;CLEAR CH1 MASK BIT 
CLR2	EQU	002H	;CLEAR CH2 MASK BIT
FULMSK	EQU	0FFH	;FULL MASK REGISTER
SMSK	EQU	0FAH	;SINGLE MASK REGISTER
SET0	EQU	004H	;SET CH0 MASK BIT
SET1	EQU	005H	;SET CH1 MASK BIT
;
	LD A,COMV	;SELECT COMMAND OPTIONS
	OUT (DMACOM),A	;
	LD A,MODE0	;WD1000 WRITE DISK TO MEMORY
	OUT (DMAMOD),A	; 
	LD A,MODE1	;FLOPPY WRITE DISK TO MEMORY 
	OUT (DMAMOD),A	; 
	LD A,MODE2	;CRT READ MEMORY TO CRT CONTROLLER(AUTO)
	OUT (DMAMOD),A	;
	LD A,DMAMSK	;SET ALL MASK BITS
	OUT (FULMSK),A	;
PAGE
;CTC INITIALIZATION
;  CHANNEL0: NOT USED DURING BOOTSTRAP
;  CHANNEL1: NOT USED DURING BOOTSTRAP
;  CHANNEL2: INTERRUPT INPUT FOR DISPALY  
;  CHANNEL3: INTERRUPT INPUT FOR FLOPPY CONTROLLER
;
CTCCH0	EQU	0CH	;CHANNEL0 ADDRESS
CTCCH1	EQU	0DH	;CH1 
CTCCH2	EQU	0EH	;CH2
CTCCH3	EQU	0FH	;CH3
CTCINT	EQU	10H	;INTERRUPT VECTOR FOR CTC
			;  DISPLAY INTERRUPT TABLE ENTRY =14H
 			;  FLOPPY INTERRUPT TABLE ENTRY = 16H
CTCMOD	EQU     0D7H	;MODE= INTERUPT AFTER ONE COUNT
CTCCNT	EQU	001H	;CTC COUNT = 1 
CTCRES	EQU	003H	;RESET CHANNEL COMMAND
; 
;
	LD A,CTCINT	;SET CTC INTERRUPT VECTOR
	OUT (CTCCH0),A	;
	LD A,CTCRES	;
	OUT (CTCCH0),A	;RESET CHANNEL0
	OUT (CTCCH1),A	;RESET CHANNEL1 
	LD A,CTCMOD	;SET CHANNEL2 MODE 
	OUT (CTCCH2),A	;
	LD A,CTCCNT	;SET CHANNEL2 COUNT
	OUT (CTCCH2),A	; 
	LD A,CTCMOD	;SET CHANNEL3 MODE  
	OUT (CTCCH3),A	;
	LD A,CTCCNT	;SET CHANNEL3 COUNT
	OUT (CTCCH3),A	;
PAGE
;CTC2 INITIALIZATION
;  CHANNEL0: INTERRUPT INPUT FOR WD1000 HARDDISK CONTROLLER
;  CHANNEL1: NOT USED
;  CHANNEL2: NOT USED
;  CHANNEL3: NOT USED
;
CT2CH0	EQU	44H	;CHANNEL0 ADDRESS REGISTER
CT2CH1	EQU	45H	;CH1 ADDR
CT2CH2	EQU	46H	;CH2 ADDR
CT2CH3	EQU	47H	;CH3 ADDR
CT2INT	EQU	08H	;INTERRUPT TABLE ENTRY FOR WD1000
;
;
	LD A,CT2INT	;SET INT VEC.
	OUT (CT2CH0),A	;
	LD A,CTCMOD	;SET CH0 MODE-INTERRUPT AFTER ONE COUNT
	OUT (CT2CH0),A	;
	LD A,CTCCNT	;SET COUNT
	OUT (CT2CH0),A	;
	LD A,CTCRES	;
	OUT (CT2CH1),A	;RESET CH1
	OUT (CT2CH2),A	;RESET CH2
	OUT (CT2CH3),A	;RESET CH3
PAGE
;INITIALIZATION OF THE DISPLAY BUFFER
;
	LD HL,DSPSTR	;INITIALIZE BUFFER TO ' ' CHARACTERS
	LD DE,DSPSTR+1	;
	LD BC,07CFH	;
	LD (HL),' '     ;
	LDIR		;
	LD HL,RCCOL	;MOVE COLOUR AND THE ' RC700' PROMT TO            	   	     	
	LD BC,TCMOP-RCCOL
	LD DE,DSPSTR	;THE MEMORY DISPLAYBUFFER
	LDIR		;
PAGE
;INITIALIZATION OF THE INTEL 8275 DISPLAY CONTROLLER
;
;
CRTCOM	EQU	01	;CRT CONTROL REGISTER
CRTDAT	EQU	00	;CRT DATA REGISTER
LCURS	EQU	80H	;LOAD CURSOR COMMAND
CRTEN	EQU    0A0H	;CRT ENABLE INTERRUPT
PRECC	EQU    0E0H	;PRESET COUNTERS COMMAND
STDISP	EQU    023H	;START DISPLAY
CRTRES	EQU	00H	;RESET CRT CONTROLLER
PARAM1	EQU    04FH	;NORMAL ROWS,80CHAR/ROW
PARAM2	EQU    098H	;25 ROWS PER FRAME
PARAM3	EQU	7AH	;UNDERLINE IN POS 8-10 POS PER CHARACTER
PARAM4	EQU	4DH	;CURSOR FORMAT BLOCK, BLINK AND REVERSE VIDEO
;
;
	LD A,CRTRES	;RESET CRT CONTROLLER   
	OUT (CRTCOM),A	;
	LD A,PARAM1	;SET CHAR/ROW
	OUT (CRTDAT),A	;
  	LD A,PARAM2	;SET ROWS/FRAME
	OUT (CRTDAT),A	;
	LD A,PARAM3	;
	OUT (CRTDAT),A	;SET LINES PER CHAR
	LD A,PARAM4	;SET CURSER FORMAT
	OUT (CRTDAT),A	;
	LD A,LCURS	;LOAD CURSOR POSITION
	OUT (CRTCOM),A	;
	XOR A		;A:=0
	OUT (CRTDAT),A	;CURSOR X POS:=0
	OUT (CRTDAT),A	;CURSOR Y POS:=0
	LD A,PRECC	;PRESET COUNTERS
	OUT (CRTCOM),A	;
	LD HL,DSPSTR	;
	LD A,L		;SET LOW ADDRESS IN DMA CHANNEL2
	OUT (CH2ADR),A	;
	LD A,H		;SET HIGH ADDRESS IN DMA CHANNEL2
	OUT (CH2ADR),A	;
	OUT (CLBP),A	;CLEAR BYTE COUNTER
	LD A,0CFH	;SET WORD COUNT LOW
	OUT (WCREG2),A	;
	LD A,07H	;SET WORD COUNT HIGH 
	OUT (WCREG2),A	;
	LD A,CLR2	;CLEAR DMA CHANNEL2 MASK BIT
	OUT (SMSK),A	;
	LD A,STDISP	;START DISPLAY AND PROMT ' RC700'
	OUT (CRTCOM),A	;
PAGE
	XOR A		;
	LD (FLBFLG),A	;FLOPPY BOOT FLAG:=0
	LD (T_FLG),A	;TEST FLAG:=0
 	CALL DUMINT	; CLEAR DAISY CHAIN
                	; AND ENABLE INTERRUPTS TO RECOGNIZE KEYBOARD 
			;INTERVENTION


PAGE   
;**************************************************************************** *                                                                 
;*  HARD DISK AUTOLOAD SECTION                                                *
;******************************************************************************
;
REPHD:	XOR A		;
	LD (ERFLAG),A	;ERRORFLAG:=FALSE
	LD (HD_FLG),A	;HD_FLG:=FALSE
	CALL HDREST	;RESTORE DRIVE
	LD BC,0FFFFH	;WHILE NOT READY OR NOT TIME OUT DO
HDW1:			;BEGIN
	LD A,(HD_FLG)	; (*CHECK FLAG*)
	OR A		;
	JR NZ,HD_RDY	;
	DEC BC  	;  TIME:=TIME-1
	LD A,B		;  IF TIME=0 THEN TIMEOUT:=TRUE
	OR C		;
	JR NZ,HDW1	;END
	LD A,(T_FLG)	;
	OR A		;  IF FORCE TEST THEN GO TO ROM2
	JP NZ,ROM2	;
	JP FLOPPY	;IF TIMEOUT THEN GO TO FLOPPY BOOT
;
HD_RDY:	LD A,(FLBFLG)	;(*HARDDISK ONLINE!*)
	OR A		;IF FORCE FLOPPY_BOOT THEN GO TO FLOPPY
	JP NZ,FLOPPY	;
	LD A,(T_FLG)	;
	OR A		;IF FORCE TEST THEN GO TO ROM2
	JP NZ,ROM2	;
 	LD A,(ERFLAG)	; 
	OR A		;IF RESTORE ERROR THEN TRY RESTORE AGAIN
	JR NZ,REPHD	;
PAGE
	LD BC,9300H	;CHECK FLAGS
WRF:	LD A,(FLBFLG)	;WHILE NOT TIMEOUT DO
	OR A		;BEGIN
	JP NZ,FLOPPY	;  IF FORCE FLOPPY_BOOT THEN GO TO FLOPPY
	LD A,(T_FLG)	;
	OR A		;
	JP NZ,ROM2	;  IF FORCE TEST THEN GO TO ROM2
	DEC BC		;  
	LD A,B		;  TIME:=TIME-1 (*WAIT APP 0.7 SEC*)
	OR C		;
	JR NZ,WRF	;
			;END

		
PAGE
	OUT (RAMEN),A	;HARDDISK RECOGNIZED ENABLE RAM IN PROM1 ADDRESS AREA
			;
			;READ CONFIGURATION SECTOR FROM HARDDISK
			;
	XOR A		;
	LD (HD_FLG),A	;
	LD (ERFLAG),A	;
	LD B,HEAD1	;CYLLINDER 0 HEAD 1
	LD C,15		;SECTOR 15
	CALL STSKFL	;SET UP TASKFILE FOR WD1000
	LD C,CH0ADR	;DMA CHANNEL0
	LD HL,0		;MEMORY ADDRESS 00 
	LD DE,511	;TRANSFER 512 BYTES
	LD A,SET0	;DMA SETMASK
	CALL STPDMA	;INITIALIZE AND ENABLE DMA TRANSFER
	LD A,HDREAD	;WD1000 READ SECTOR COMMAND
	OUT (HCMDRG),A	;
HDW2:	LD A,(HD_FLG) 	;WHILE HDC BUSY DO WAIT
	OR A		;
	JR Z,HDW2	;
	LD A,(ERFLAG)	;IF HD_ERROR THEN GO TO FLOPPY_BOOT
	OR A		;
	JP NZ,FLOPPY	;
	LD HL,20	;
	LD A,(HL)	;
	CP 1		;IF NOT HD BOOTDISK THEN GO TO FLOPPY_BOOT
	JP NZ,FLOPPY	;
			;ELSE BOOT FROM HD DISK
PAGE
;AUTOLOAD FROM HARDDISK
;LOAD BIOS FROM CYLLINDER 0 SIDE 0 TO MEMORY ADDRESS 00 AND FORWARD
;
;
	XOR A		;
	LD (SECTOR),A	;SECTOR:=0
	LD HL,00	;
	LD (MEMADR),HL	;MEMORY_POINTER:=0
HDREP1:	XOR A		;FOR SECTOR:=0 TO 15
	LD (HD_FLG),A	;BEGIN CLEAR HD_FLG
	LD (ERFLAG),A	;
	LD A,(SECTOR)	;
	LD C,A		;
	LD B,HEAD0	;
	CALL STSKFL	;  SET UP TASK FILE FOR WD1000
	LD C,CH0ADR	;
	LD HL,(MEMADR)	;
	LD DE,511	;
	LD A,SET0	;
	CALL STPDMA	;  INITIALIZE AND ENABLE DMA TRANSFER
	LD A,HDREAD	;
	OUT (HCMDRG),A	;  WD1000 READ SECTOR COMMAND
HDW3:	LD A,(HD_FLG)	;  WHILE HDC BUSY DO WAIT
	OR A		;
	JR Z,HDW3	;
      	LD A,(ERFLAG)	;  IF HD ERROR THEN GO TO FLOPPY=BOOT
	OR A		;
	JP NZ,FLOPPY	;
	LD HL,(MEMADR)	;  ELSE BEGIN
	LD DE,512	;         MEMORY_POINTER:=MEMORY_POINTER+512
	ADD HL,DE	;
	LD (MEMADR),HL	;
	LD A,(SECTOR)	;
	INC A		;         SECTOR:=SECTOR+1
 	LD (SECTOR),A	;
	CP 16		;       END
	JR NZ,HDREP1	;END
	LD HL,(00)	;LOAD CP/M BOOT ADDRESS
	JP (HL)		;AND TRANSFER CONTROL TO BIOS
PAGE
;
;*****************************************************************************
;*               							     *
;* FLOPPY_BOOT SECTION							     *
;*									     *
;*****************************************************************************
;
FLOPPY:	LD A,(T_FLG)	;IF FORCE TEST THEN GO TO ROM2
	OR A		;
	JP NZ,ROM2	;
	CALL INITFL	;FLOPPY_BOOT INITIALIZE FDC AND RECALIBRATE DRIVE0
	OUT (RAMEN),A	; FLOPPY RECOGNIZED ENABLE RAM IN PROM1 ADDRESS AREA
	LD HL,00	; MEMORY_ADR:=0
	LD (MEMADR),HL	;
	CALL READ	; READ_TRACK0 
PAGE
;
;CHECK FOR ID-COMAL OR (CP/M - COMAL80) BOOT
;
	LD BC,6		;
	LD HL,TCMOP-6	; HL POINTS TO ' RC700' TEXT
	LD DE,1		; DE POINTS TO THE IMAGE LOADED FROM DISK
	CALL COMSTR	; COMPARE STRINGS
	JP Z,IDBOOT	; IF MEMORY IMAGE TEXT=' RC700' THEN
			; GO TO ID-COMAL BOOT
 	LD BC,5		;
	LD HL,TCMOP-6	; HL POINTS TO ' RC700' TEXT
	LD DE,7		; DE POINTS TO THE IMAGE LOADED FROM DISK
	CALL COMSTR	; COMPARE STRINGS
	JR Z,CPCOMB	;IF THE FIRST FIVE CHAR OF MEMORY IMAGE IS DIFFERENT
			;FROM ' RC70' THEN GO TO ERROR
			;ELSE GO TO CP/M-COMAL80 BOOT
ERXIT:	LD HL,ERMES3	; IF ERROR THEN WRITE('* NO SYSTEM FILES *')
	JP ERR		;
PAGE
; 
;COMAL80 - CP/M AUTOLOAD
;
CPCOMB: LD IX,COMBUF	;INITIALIZE READ COMMAND BUFFER
	LD (IX),DUALC	;DUAL DENSITY READ COMMAND
	LD (IX+1),DR0H1	;DRIVE 0 HEAD 1
	LD (IX+5),BDSEC	;256 BYTES PER SECTOR
	LD (IX+7),DUAGPL;GAB 3 DUAL DENSITY
	LD (IX+8),DUADTL; DTL DUMMY=FFH
	                ;
	LD A,5		;
	LD (REPTIM),A	;
REPRD2:	XOR A		;REPEAT
	LD (FL_FLG),A	;CLEAR FLOPPY INT FLAG
	IN A,(SW1)	;
	AND 80H
	JR Z,IMBUF	;  IF MINI_DRIVE THEN
	LD DE,MIBYT1	;  BYTES TO TRANSFER:= 256*16
	JR INID		;
IMBUF:	LD DE,MXBYT1	;  ELSE BYTES TO TRANSFER:= 256*26
INID:	LD C,CH1ADR	;  INITIALIZE AND ENABLE DMA
	LD A,SET1	;
	LD HL,(TRBYT)	;
	INC HL		;TO GET THE FIRST FREE ADDRESS
	CALL STPDMA	;
	CALL FLRTRK	;  READ CYLLINDER 0 SIDE 1
	CALL READOK	;  WAIT- CHECK READING OK 
	JR C,REPRD2	;UNTIL REPTIM=0 OR NOT ERROR
			;
	LD HL,(00)	;LOAD BOOTADDRESS
	JP (HL)		;AND TRANSFER CONTROL
PAGE
;*****************************************************************************
;* 									     *
;* ID COMAL AUTOLOAD SECTION:					             *
;*  MINI DRIVES: THE SYSTEM CODE IS ON TRACK 1-3		             *
;*               SIDE0= 16 SECTORS
;*               SIDE1= 10 SECTORS(LAST 6 SECTORS GARBAGE)
;*               ALWAYS DOBBELT SIDED AND SINGLE DENSITY
;*
;*  MAXI DRIVES: THE SYSTEM CODE IS ON TRACK 1-3
;*                ALLWAYS SINGLE SIDED AND SINGLE DENSITY
;* 							                     *    		 	 
;*****************************************************************************

MTRK	EQU	86H	;MINI DRIVES MULTITRACK FDC COMMAND
MINS1	EQU	1280	;BYTES ON SIDE 1 MINI DRIVES ID-COMAL
SBID	EQU	3328	;SIGNIFICANTE BYTES ON ONE CYLINDER          
IDBADR	EQU	1000H	;ID COMAL BOOT ADDRESS

;
IDBOOT:			;
	IN A,(SW1)	;IF MINI_DRIVES THEN
	AND 80H		;
	JR Z,CATCH	;
	LD A,DR0H1	; READ CATALOG FROM TRACK0 SIDE1
	LD (COMBUF+1),A	;
	LD HL,MIBYT0+1	;
	LD (MEMADR),HL	;
	CALL READ	;
PAGE
;ID COMAL CATALOG CHECK
IDCAT	EQU	0B60H	;ID COMAL CATALOG START ADDRESS-20H
FILDI	EQU	020H	;ENTRY DISPLACEMENT
FILTY	EQU	013H	;SYSTEM-FILE TYPE VALUE
OUTCAT	EQU	00EH    ;MOST SIGNIFICANT ADDRESS BYTE OF THE FIRST
			;PAGE THAT LIES OUT OF THE CATALOG ADDRESS SPACE 
;THE CATALOG CONTAINS 12 ENTRIES EACH 32 BYTES LONG
;THE LAST ENTRY ADDRESS IS 0DE0H
;
CATCH:	LD HL,IDCAT	;ENTRY NUMBER:= 0
REPENT:	LD DE,FILDI	;WHILE ENTRY.EMPTY AND ENTRY NUMBER<13 DO
	ADD HL,DE	;
	LD A,OUTCAT	;
	CP H		;
	JP Z,DIRERR	; ENTRY NUMBER:= ENTRY NUMBER+1;
	LD A,(HL)	;
	OR A		;
	JR Z,REPENT	;
			;IF ENTRY NUMBER>12 THENGO TO DIR_ERROR
	PUSH HL		;
	INC HL		;
	LD DE,SYSM-1	;IF ENTRY.TEXT<>'SYSM' THEN GO TO DIR_ERROR
	LD BC,4		;
	CALL COMSTR	;
	JP NZ,DIRERR	;
	POP HL		;
	PUSH HL		;
	LD DE,FILDI	;ENTRY NUMBER:= ENTRY NUMBER+1
	ADD HL,DE	;
	PUSH HL		;
	INC HL		;
	LD DE,SYSC-1	;IF ENTRY.TEXT<>'SYSC' THEN GO TO DIR_ERROR
	LD BC,4		;
	CALL COMSTR	;
	JP NZ,DIRERR	;
	LD B,2		;FOR I:=ENTRY NUMBER DOWNTO ENTRY NUMBER-1 DO
	LD DE,8		;
REPATR:	POP HL		; IF ENTRY(I).ATTRIBUTE<>SYSTEMFILE THEN
	ADD HL,DE	; GO TO DIR_ERRROR
	LD A,(HL)	;
	AND 3FH		;
	CP FILTY	;
	JP NZ,DIRERR	;
	DJNZ REPATR	;
PAGE
;LOAD ID COMAL SYSTEM CODE		 		
	LD HL,00	;
	LD (MEMADR),HL	; MEMORY_ADDRESS:=0
	LD A,1		;
	LD (TRK),A	; TRACK:=1
	IN A,(SW1)	;
	AND 80H		;
	JP Z,MAXIRD	;  IF MINI=DRIVES THEN
	LD A,(TRK)	;BEGIN
IDRL1:	LD B,A		;  FOR I:=1 TO 9 DO
	CALL FLO7	;  BEGIN
	LD A,(TRK)	;
	LD (CURID),A	;
	XOR A		;    
	LD (COMBUF+1),A	;    SET DRIVE 0 HEAD 0
 	CALL READ	;    SEEKTRACK(TRACK)
	LD HL,(MEMADR)	;    READTRACK(SIDE0)
	LD DE,MIBYT0+1	;    MEMORY_ADR:=MEMORY_ADR+16*128
 	ADD HL,DE	;
	LD (MEMADR),HL	;
	LD A,DR0H1	;
	LD (COMBUF+1),A	;    SET DRIVE 0 HEAD 1
	CALL READ	;    READTRACK(SIDE1)
	LD HL,(MEMADR)	;
	LD DE,MINS1	;
	ADD HL,DE	;    MEMORY=ADR:=MEMORY_ADR+10*128
	LD (MEMADR),HL	;
	LD A,(TRK)	;
	INC A		;
	LD (TRK),A	;
	CP 10		;
	JR NZ,IDRL1	;  END
	JR IDFIN	;     
MAXIRD:	LD A,(TRK)	;ELSE
IDRL2:	LD B,A		;FOR I:=1 TO 9 DO 
	CALL FLO7	;BEGIN
	LD A,(TRK)	;  SEEKTRACK(TRACK)
	LD (CURID),A	;  CURRENT CYL NUMBER:=TRACK
	CALL READ	;  READTRACK(TRACK)
	LD HL,(MEMADR)	;
	LD DE,SBID	;MEMORY_ADDRESS:=MEMORY_ADDRESS+(26*128)
	ADD HL,DE	;
	LD (MEMADR),HL	;
	LD A,(TRK)	;
	INC A		;
	LD (TRK),A	;
	CP 10		;
	JR NZ,IDRL2	;END(*FOR LOOP*)
			;
IDFIN:	LD A,COMV	;
	OUT (DMACOM),A	;
	LD A,MODE0	; INITIALIZE DMA FOR ID-COMAL USE
	OUT (DMAMOD),A	;
	LD A,MODE1	;
	OUT (DMAMOD),A	;
	LD A,4AH	;
	OUT (DMAMOD),A	;
	LD A,4BH	;
	OUT (DMAMOD),A	;
	LD A,DMAMSK	;
	OUT (FULMSK),A	;
	LD A,PENINT	; ENABLE KEYBORD INTERRUPTS IF DISABLED BY
	OUT (KEYCON),A	; THE KEYBOARD INTERRUPT SERVICE RUTINE
			;		
	LD HL,IDBADR	; LOAD ID COMAL BOOT ADDRESS
	JP (HL)		; AND TRANSFER CONTROL
PAGE
DIRERR:	LD HL,ERMES3	;PROCEDURE ID-COMAL DIRECTORY_ERROR
	JP ERR		;
;
;
;
COMSTR:	INC DE		;PROCEDURE COMPARE_STRINGS
	LD A,(DE)	;
	CPI		;
	RET NZ		;
	JP PE,COMSTR	;
	RET		;
  
PAGE
;************************************************************************
;*									*
;*   FLOPPY ROUTINES:							*
;*									*
;************************************************************************
;
FDC	EQU	04H	;FLOPPY COMMAND REGISTER
FDD	EQU	05H	;FLOPPY DATA REGISTER

;
;
;
READ:			;PROCEDURE READTRACK
	LD A,5		;BEGIN
	LD (REPTIM),A	;  REPEAT
RDL11:	XOR A		;    CLEAR FLOPPY_INT FLAG
	LD (FL_FLG),A	;
	LD C,CH1ADR	;
	LD A,SET1	;
	LD HL,(MEMADR)	;
	LD DE,(TRBYT)	;
	CALL STPDMA	;    INITIALIZE AND ENABLE DMA
	CALL FLRTRK	;    READ_TRACK 
	CALL READOK	;
	JR C,RDL11	;  UNTIL RETIM=0 OR NOT ERROR;
	RET		;END
PAGE
;
INITFL:	IN A,(SW1)	;PROCEDURE INITIALIZE FLOPPY
	AND 80H		;BEGIN
	JR Z,IFDC0	;  IF MINI_DRIVES THEN
	LD A,0FH	;  BEGIN
	LD (FDCINI+2),A	;    SET SRT:=16MS AND HUT:=240MS
	LD HL,MIBYT0	;    TRANSFER_BYTES:=16*128
	LD (TRBYT),HL	;
	CALL FDSTAR	;  END
IFDC0:	IN A,(FDC)	;  WHILE FDC BUSY DO WAIT
	AND 01FH	;
	JR NZ,IFDC0	;
	LD HL,FDCINI	;  FOR I:=(B) DOWNTO 1 DO
	LD B,(HL)	;  BEGIN
IFDC1:	INC HL		;
	CALL FLO2	;    WAIT_READY_WRITE
	LD A,(HL)	;
	OUT (FDD),A	;    WRITE FDC INIT COMMAND
	DJNZ IFDC1	;  END
	LD BC,0FFFFH	;
	LD A,5		;
	LD (REPTIM),A	;
RECREP: XOR A		;  REPEAT
	LD (FL_FLG),A	;    CLEAR FLOPPY INT FLAG
	CALL FLO4	;    RECALIBRATE DRIVE0
			;    WHILE FDC NOT READY OR NOT TIMEOUT DO
FW1:	LD A,(FL_FLG)	;    BEGIN
	OR A		;      CHECK FLOPPY INT FLAG FOR FDC READY
	JR NZ,FD_RDY	;
	DEC BC		;      TIME:=TIME-1
	LD A,C		;
	OR B		;
	JR NZ,FW1	;     END
	LD HL,ERMES1	;     IF TIMEOUT THEN WRITE(PLEASE INSERT DISKETTE)
	JP ERR		;     ERROR_ABORT
FD_RDY:	LD A,(RSTAB)	;     IF RECALIBRATE_ERROR THEN TIMES:=TIMES-1
	AND 0D0H	;
	RET Z		;
	LD A,(REPTIM)   ;
	DEC A		;
	LD (REPTIM),A	;
	JR NZ,RECREP	;  UNTIL TIMES=0 OR NOT ERROR
	LD HL,ERMES1	;  IF RECALIBRATEERROR THEN
	JP ERR		;  WRITE(PLEASE INSERT DISKETTE)
			;  ERROR_ABORT  	
			;END(*PROCEDURE INITIALIZE FLOPPY*)
PAGE
;
FLO2:	IN A,(FDC)	;PROCEDURE WAIT_READY_WRITE
	AND 0C0H	;
	CP 080H		;
	JR NZ,FLO2	;
	RET		;
;
;
;
FLO3:	IN A,(FDC)	;PROCEDURE WAIT_READY_READ
	AND 0C0H	;
	CP 0C0H		;
	JR NZ,FLO3	;
	RET		;
;
;
;
FLO4:			;PROCEDURE RECALIBRATE_DRIVE0
			;BEGIN
	CALL FLO2	;  WAIT_READY_WRITE
	LD A,7		;
	OUT (FDD),A	;  RECALIBRATE COMMAND
	CALL FLO2	;  WAIT_READY_WRITE
	LD A,00		;
	OUT (FDD),A	;  SELECT DRIVE0
	RET		;
PAGE
FLO6:			;PROCEDURE SENSE_INTERRUPT_STATUS
			;BEGIN
	CALL FLO2	;  WAIT_READY_WRITE
	LD A,8		;
	OUT (FDD),A	;  SENSE INTERRUPT COMMAND
	CALL FLO3	;  WAIT_READT_READ
	IN A,(FDD)	;
	LD (RSTAB),A	;  RSTAB:=STATUS_REGISTER_0
	AND 0C0H	;
	CP 80H		;
	RET Z		;
	CALL FLO3	;  WAIT_READY_READ
	IN A,(FDD)	;  
	LD (RSTAB+1),A	;  RSTAB1:=STATUS_REGISTER_1
	RET		;END
;
;
;
FLO7:			;PROCEDURE SEEK_TRACK
			;"NEW CYLINDER NUMBER IN B REGISTER"
	XOR A		;BEGIN
	LD (FL_FLG),A	;  "CLEAR FLOPPY INT FLAG"
	CALL FLO2	;  WAIT_READY_WRITE 
	LD A,0FH	;
	OUT (FDD),A	;  SEEK TRACK COMMAND
	CALL FLO2	;  WAIT READY WRITE
	XOR A		;
	OUT (FDD),A	;  SET DRIVE0/HEAD0
	CALL FLO2	;  WAIT READY WRITE
	LD A,B		;
	OUT (FDD),A	;  SET NEW CYLINDER NUMBER
SREP1:	LD A,(FL_FLG)	;
	OR A		;
	JR Z,SREP1	;  WHILE FDC BUSY DO;
	LD A,(RSTAB)    ;
	AND 0F0H	;  IF SEEK_ERROR THEN
	CP 20H		;
	RET Z		;  WRITE("*DISKETTE ERROR*)
	LD HL,ERMES0	;
	JP ERR		;

			
PAGE
RSULT:			;PROCEDURE READ_RESULT
			;BEGIN
	LD HL,RSTAB	;
	LD D,3		;
RSL1:	CALL RSTAT	;  FOR I:=1 TO 3 DO RESULT_TABLE(I):=FDC_STATUS(I-1)
	RET Z		;
	DEC D		;
	JR NZ,RSL1	;
	LD D,4		;
	LD HL,CURID	;
RSL2:	CALL RSTAT	;  FOR I:=1 TO 4 DO CURID(I):=FDC_ID(I)
	RET Z		;
	DEC D		;
	JR NZ,RSL2	;
	RET		;END
;
;
RSTAT:			;PROCEDURE READ_FLOPPY_RESULT
	CALL FLO3	;
	IN A,(FDD)	;
	LD (HL),A	;
	INC HL		;
	LD A,4		;
RLOOP1:	DEC A		;
	JR NZ,RLOOP1	;CRITICAL FDC TIMING
	IN A,(FDC)	;
	AND 10H		;
	RET		;
PAGE
	
FDSTAR:	LD A,1		;PROCEDURE START_MINI_MOTOR
	OUT (SW1),A	;
	LD BC,600H	;
W1:	LD A,0FFH	; WAIT(1 SEC)
W2:	DEC A		;
	JR NZ,W2	;
	DEC BC		;
	LD A,C		;
	OR B		;
	JR NZ,W1	;
	RET		;
;
;
;
FDSTOP:	IN A,(SW1)	;PROCEDURE STOP_MINI_MOTOR
	AND 80H		;IF MINI_DRIVES THEN
	RET Z		; 
	LD A,0
	OUT (SW1),A	; STOP_MOTOR
	RET		;
PAGE
FLRTRK:	DI		;
	LD HL,COMBUF	;PROCEDURE FLOPPY_READTRACK	
	LD B,9		;FOR I:1 TO 9 DO
REPCOM:	CALL FLO2	;BEGIN
	LD A,(HL)	;  WAIT_READY_WRITE
	OUT (FDD),A	;  WRITE.CONTROLLER(COMBUF(I))
	INC HL		;
	DEC B		;
	JR NZ,REPCOM	;
	EI		;
	RET		;END
;
;
;
READOK:	LD BC,0FFFFH	;PROCEDURE CHECK_READING_OK     
WFLP:	LD A,(FL_FLG)	;BEGIN				
	OR A		;
	JR NZ,RDOK?	;  WHILE FDC BUSY AND NOT TIMEOUT DO;
	DEC BC		;
	LD A,B		;
	OR C		;
	JR NZ,WFLP	;
	JR EEXIT1	; IF TIMEOUT THEN GO TO ERROR
RDOK?:	LD A,(RSTAB)	;
	AND 0C0H	;"THE AND OPERATION WILL CLEAR CARRY FLAG"
	RET Z		;
	CP 40H		;
	JR NZ,CEXIT	;
	LD A,(RSTAB+1)	;
	AND 035H	;
	RET Z		; IF NOT READ_ERROR THEN RETURN
CEXIT:	LD A,(REPTIM)	; ELSE BEGIN
	DEC A		;        REPEAT_TIMES:=REPEAT_TIMES-1 
	LD (REPTIM),A	;
	JR Z,EEXIT	;        IF REPEAT_TIMES>0 THEN     
	SCF		;        SET_CARRY
	RET		;        ELSE
EEXIT:  LD HL,ERMES0	;        WRITE('*DISKETTE ERROR*')
	JP ERR		;
EEXIT1:	LD HL,ERMES1	;        WRITE (*PLEASE INSERT DISKETTE*)
	JP ERR		;
PAGE
;FLOPPY DISK SETUP CONSTANTS
;
;MINI DRIVES CONSTANTS
MIBYT0	EQU	2047	;BYTES TRACK0 SODE0(16*128)-1
MIBYT1	EQU	4095	;BYTES TRACK0 SIDE1(16*256)-1
;
;MAXI DRIVES CONSTANTS
;
MXBYT0	EQU	3327	;BYTES TRACK0 SIDE0(26*128)-1 
MXBYT1	EQU	6655	;BYTES TRACK0 SIDE1(26*256)-1
;
;MISCELLENEOUS DISK CONSTANTS
;
DUALC	EQU	042H	;DUAL DENSITY READ COMMAND
DUADTL	EQU	0FFH	;DTL FOR DUAL DENSITY
DUAGPL	EQU	00EH	;GAB3 FOR DUAL DENSITY
DR0H1	EQU	004H	;DRIVE0 HEAD1
BDSEC	EQU	001H	;N FOR DUAL DENSITY
MINEOT	EQU	010H	;MINIDRIVES EOT=16
;
;
;READ DISK COMMAND BUFFER
COMBUF:	DB 02H		;READ TRACK COMMAND(SINGLE DENSITY)
	DB 00H		;DRIVE0/HEAD0
CURID:			;CURRENT FLOPPY ID INFO
	DB 00H		;CYLINDER NUMBER
	DB 00H		;HEAD ADDRESS
	DB 01H		;RECORD NUMBER
	DB 00H		;RECORD LENGTH
        
	DB 1AH		;EOT
	DB 07H		;GAB3
	DB 80H		;DTL
    
TRBYT:	DW MXBYT0	;NUMBER OF BYTES TO TRANSFER DURING DMA FROM ONE
			;TRACK(DEFAULT MAXI-DRIVE TRACK0 SIDE0)

FDCINI:			;FDC SPECIFY COMMAND BUFFER
	DB 3		;NUMBER OF COMMANDS
	DB 3		;SPECIFY COMMAND
	DB 0DFH		;SRT=3MS HUT=240MS
	DB 028H		;HLT=40MS DMAMODE

	
;****************************************************************************
;*
;*  HARD DISK PROCEDURES:
;*
;****************************************************************************
;
;WINCHESTER WD1000 CONTROLLER IO ADDRESSES
;
HWPCMD	EQU	061H	;WRITE PRECOMP REGISTER
HSECCT	EQU	062H	;SECTOR COUNT REGISTER
HSECNO	EQU	063H	;SECTOR NUMBER REGISTER
HCYLLO	EQU	064H	;CYLINDER LOW ADDRESS REGISTER
HCYLHI	EQU	065H	;CYLINDER HIGH ADDRESS REGISTER
HSZDHD	EQU	066H	;SIZE/DRIVE/HEAD
HCMDRG	EQU	067H	;COMMAND REGISTER
HDSTAT	EQU	067H	;STATUS REGISTER
HDERR	EQU	061H	;ERROR REGISTER
;
;WD1000 CONSTANTS
;
HDRES	EQU	011H	;RESTORE COMMAND STEPPING RATE= 0.5MS
HDREAD	EQU	028H	;READ SECTOR COMMAND DMA MODE
HEAD0	EQU	020H	;512 BYTES/SECTOR DRIVE0 HEAD0
HEAD1	EQU	021H	;512 BYTES/SECTOR DRIVE0 HEAD1
; 
;
;
HDREST:	LD B,HEAD0	;PROCEDURE RESTORE_HARDDISK
	LD C,0		;BEGIN
	CALL STSKFL	;  SELECT HEAD0-SECTOR NUMBER 0-SET UP TASKFILE
	LD A,HDRES	;
	OUT (HCMDRG),A	;  RESTORE DISK
	RET		;END
;
;
;
STSKFL:			;PROCEDURE SET_UP_TASKFILE
			;PARAMETERS:
			;  SIZE/DRIVE/HEAD IN B REGISTER
			;  SECTOR NUMBER IN C REGISTER
			;THE BOOTSTRAPLOADER WILL ALLWAYS READ FROM
			;CYLLINDER 0
	XOR A		;BEGIN
	OUT (HWPCMD),A	;  WRITEPRECOMP:=0
	OUT (HSECCT),A	;  SECTOR COUNT:=0
	OUT (HCYLLO),A	;  CYLINDER LOW ADDR:=0
	OUT (HCYLHI),A	;  CYLINDER HIGH ADDR:=0
	LD A,C		;
	OUT (HSECNO),A	;  SECTOR NUMBER:=(C REG)
	LD A,B		;
	OUT (HSZDHD),A	;  (SIZE/DRIVE/HEAD):=(B REG)
	RET		;END
PAGE
STPDMA:			;PROCEDURE SET_UP_DMA
			;READING FOMR DISK TO MEMORY
			;CHANNEL ADDRESS IN C REGISTER
			;DMA MEMORY ADDRESS IN HL REGISTER
			;NUMBER OF BYTES TO TRANSFER IN DE REGISTER
			;SETMASK IN A REGISTER
	DI		;BEGIN
	OUT (SMSK),A	;  SET CHANNEL MASK
	OUT (CLBP),A	;  CLEAR BYTE POINTER
	OUT (C),L	;  SET LOW ADDRESS
	OUT (C),H	;  SET HIGH ADDRESS
	INC C		;
	OUT (C),E	;  SET WORD COUNT LOW
	OUT (C),D	;  SET WORD COUNT HIGH
	RES 2,A		;  CLEAR MASK BIT
	OUT (SMSK),A	;  ENABLE DMA
	EI	 	;
	RET		;END
PAGE
;*****************************************************************************         	
;*
;* INTERRUPT SERVICE RUTINES:
;*
;*****************************************************************************
;
DUMINT:	EI 		;PROCEDURE DUMMY_INTERRUPT
	RETI		;
;
;
;
KBINT:	EX AF,AF'	;PROCEDURE KEYBOARD_INTERRUPT
	IN A,(KEYDAT)	;BEGIN
	AND 05FH	;  (A):=INCHAR("MASK LOWER CASE LETTERS TO UPPER")
	CP 'F'   	;  IF FLOPPY_BOOT_CHAR THEN
	JR NZ,T22	;
	LD A,1		;
	LD (FLBFLG),A	;  FLOPPY_BOOT:=TRUE
	JR RET22	;
T22:	CP 'T'		;  ELSE IF FORCE_TEST_CHAR THEN
	JR NZ,RET22	;
	LD A,1		;
	LD (T_FLG),A	;   FORCE_TEST:= TRUE
RET22:  EX AF,AF'	;
	EI		;
	RETI	        ;END
;
;
;
HDINT:	EX AF,AF'	;PROCEDURE HARD_DISK_INTERRUPT
	EXX 		;BEGIN
	LD A,0FFH	;  HD_FLG:=FALSE
	LD (HD_FLG),A	;
	IN A,(HDSTAT)	;
	AND 51H		; MASK ALL OTHER BITS THAN
			; READY,SEEK COMPLETE AND ERROR
	CP 50H		; IF NOT READY THEN SET NOT READY_FLAG
	JR Z,HDEXIT	;  IF HARD DISK ERROR THEN
	LD A,0FFH	;  HARD_DISK_ERROR_FLAG:=TRUE
	LD (ERFLAG),A	;
HDEXIT:	EX AF,AF'	;
	EXX	 	;
	EI		;
	RETI		;END
;
;
;
FLPINT:	EX AF,AF'	;PROCEDURE FLOPPY_INTERRUPT
	EXX		;BEGIN
	LD A,0FFH	;  FLOPPY_FLAG:=FALSE
	LD (FL_FLG),A	;
	LD A,5		;  "FDC CRITICAL TIMING"
TIMFLI:	DEC A		;
	JR NZ,TIMFLI	;
	IN A,(FDC)	;
	AND 10H		; "NON DMA MODE TEST"
	JR NZ,RRES	;
	CALL FLO6	; SENSE INTERRUPT STATUS
	JR FEXIT	;
RRES:	CALL RSULT	; READ RESULT
FEXIT:	EX AF,AF'	;
	EXX		;
	EI		;
	RETI		;END
;
;
;
DISINT:	EX AF,AF'	;PROCEDURE DISPLAY_INTERRUPT
	IN A,(CRTCOM)	;REMOVE INTERRUPT BY READING STATUS
	EX AF,AF'	;
	EI		;
	RETI		;
PAGE
ERR:			;PROCEDURE ERROR_ABORT        
	LD IX,DSPSTR	;BEGIN
	LD DE,160	;  "START WRITING IN DISPLAY BUFFER LINE 2"
	ADD IX,DE	;
WCH:	LD A,(HL)	; WHILE (HL)<>0 DO 
	CP 0		;
	JR Z,FIN	;
	LD (IX),A	;  WRITE_CHAR
	INC IX		;
	INC HL		;
	JR WCH		;
FIN:	OUT (BIB),A	;  PROMT FOR ABORT TO CRT
	CALL FDSTOP	;  STOP_MINI_MOTOR
ALOOP:	XOR A		;
	OR A		;
	JR Z,ALOOP	;  ABORT
;
PAGE
;DATA AREA
T_FLG:	DB 0		;FORCE TEST FLAG
FLBFLG:	DB 0		;FORCE FLOPPY BOOT FLAG
FL_FLG:	DB 0		;FLOPPY INTERRUPT FLAG
HD_FLG:	DB 0		;HARD DISK INTERRUPT FLAG
HD$RDY: DB 0		;HARD DISK READY FLAG
;
;
;RUN TIME MESSAGES
ERMES0:	DB '* DISKETTE ERROR *',0
ERMES1:	DB '* PLEASE INSERT DISKETTE AND PRESS RESET *',0
ERMES2: DB '  ',0
ERMES3:	DB '* NO SYSTEM FILES *',0
;
;
SYSM:	DB 'SYSM'
SYSC:	DB 'SYSC'
;
;
;
;
;CRT COLOR DECRIPTION
COL	EQU	193	;COLOR ATTRIBUTE
BACK	EQU	000	;SELECT BACKGROUND
FORG	EQU	002	;SELECT FORGROUND
BLUE	EQU	004	;BLUE CANON
RED	EQU	008	;RED CANON
GREEN	EQU	016	;GREEN CANON
;
;
IF COLOR  
RCCOL:	DB COL+BACK	;NO CANONS GIVES BLACK
	DB COL+FORG+RED+GREEN; GIVING YELLOW
ELSE
RCCOL:	DB '  '		;IF NOT COLOR CRT THEN WRITE('  ')  
ENDIF
	DB ' RC700'	;RC MICRO PROMT TEXT
TCMOP:	DB ' '		;
.DEPHASE
POS$:			;LIST DEVICE OFF IN MACRO EXPANSION			
.XLIST			;
			;NOTE NUMBER OFF FREE BYTES IN PROM
;
REPT FMOVE-(POS$-BEGIN)	;;
	DB 0FFH		;;FILL REST OF PROM WITH FF'S
ENDM			;;

.LIST
;
END 
E
